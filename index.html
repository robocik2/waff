<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soft Body Blob Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body, html {
            height: 100%;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="blobCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const { Engine, Render, Runner, World, Bodies, Body, Composite, Composites, Constraint, Mouse, MouseConstraint, Events } = Matter;

        // Setup the engine
        const engine = Engine.create();
        const world = engine.world;
        world.gravity.y = 1; // Strong gravity

        // Setup the canvas and renderer
        const canvas = document.getElementById('blobCanvas');
        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                background: '#f0f0f0',
                wireframes: false
            }
        });

        // Function to create a large soft body blob (a cluster of connected circles)
        function createLargeSoftBody(x, y, gridWidth, gridHeight, particleSize) {
            const group = Body.nextGroup(true);
            const softBody = Composites.softBody(
                x - (gridWidth * particleSize) / 2,
                y - (gridHeight * particleSize) / 2,
                gridWidth, gridHeight,  // Number of particles in x and y directions
                0, 0,                   // Padding between particles
                true,                   // Whether particles are connected with constraints
                particleSize,            // Particle radius
                { 
                    friction: 0.001, 
                    restitution: 0.8,
                    render: { fillStyle: '#FF6347' } 
                },
                { 
                    stiffness: 0.05,
                    render: { visible: false } 
                }
            );

            Composite.add(world, softBody);
            return softBody;
        }

        // Create two large soft bodies (blobs) that cover about 70% of the screen space
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        const largeBlob1 = createLargeSoftBody(screenWidth * 0.3, screenHeight / 2, 10, 10, 30);  // Larger soft body 1
        const largeBlob2 = createLargeSoftBody(screenWidth * 0.7, screenHeight / 2, 10, 10, 30);  // Larger soft body 2

        // Create static walls around the screen borders
        const walls = [
            Bodies.rectangle(screenWidth / 2, 0, screenWidth, 50, { isStatic: true }),  // Top wall
            Bodies.rectangle(screenWidth / 2, screenHeight, screenWidth, 50, { isStatic: true }),  // Bottom wall
            Bodies.rectangle(0, screenHeight / 2, 50, screenHeight, { isStatic: true }),  // Left wall
            Bodies.rectangle(screenWidth, screenHeight / 2, 50, screenHeight, { isStatic: true })   // Right wall
        ];
        World.add(world, walls);

        // Handle window resize
        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            Render.lookAt(render, {
                min: { x: 0, y: 0 },
                max: { x: canvas.width, y: canvas.height }
            });
        });

        // Add mouse control and mouse interaction visibility
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: {
                    visible: true
                }
            }
        });
        World.add(world, mouseConstraint);

        // Add a hover effect to show collision with cursor
        Events.on(mouseConstraint, 'mousemove', function(event) {
            const mousePosition = event.mouse.position;
            const bodies = Composite.allBodies(world);

            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                const dx = body.position.x - mousePosition.x;
                const dy = body.position.y - mousePosition.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 50) {  // Adjust hover effect threshold
                    body.render.fillStyle = '#FF4500'; // Change color on hover
                } else {
                    body.render.fillStyle = '#FF6347'; // Reset color
                }
            }
        });

        // Run the engine
        Engine.run(engine);
        Render.run(render);

        // Run the simulation
        const runner = Runner.create();
        Runner.run(runner, engine);
    </script>
</body>
</html>
