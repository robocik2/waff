<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG-mapped Soft Body Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Composite = Matter.Composite,
              Constraint = Matter.Constraint,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Common = Matter.Common,
              Vector = Matter.Vector,
              Events = Matter.Events;

        const engine = Engine.create(),
              world = engine.world;

        const canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvas.width,
                height: canvas.height,
                wireframes: false,
                background: 'transparent'
            }
        });

        Render.run(render);

        const runner = Runner.create();
        Runner.run(runner, engine);

        // Set gravity
        engine.world.gravity.y = 0.3;

        // Create walls
        const wallThickness = 50;
        const walls = [
            Bodies.rectangle(canvas.width / 2, -wallThickness / 2, canvas.width, wallThickness, { isStatic: true }),
            Bodies.rectangle(canvas.width / 2, canvas.height + wallThickness / 2, canvas.width, wallThickness, { isStatic: true }),
            Bodies.rectangle(-wallThickness / 2, canvas.height / 2, wallThickness, canvas.height, { isStatic: true }),
            Bodies.rectangle(canvas.width + wallThickness / 2, canvas.height / 2, wallThickness, canvas.height, { isStatic: true })
        ];
        Composite.add(world, walls);

        function createLiquidBody(x, y, radius, particleRadius, svgElement) {
            const group = Body.nextGroup(true);
            const particleOptions = {
                friction: 0.05,
                restitution: 0.2,
                density: 0.002,
                collisionFilter: { group: group },
                render: { visible: false }
            };
            
            const particles = [];
            const rows = Math.ceil(radius * 2 / particleRadius);
            const cols = Math.ceil(radius * 2 / particleRadius);
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const particleX = x - radius + j * particleRadius;
                    const particleY = y - radius + i * particleRadius;
                    if (Vector.magnitude(Vector.sub({x: particleX, y: particleY}, {x, y})) <= radius) {
                        particles.push(Bodies.circle(particleX, particleY, particleRadius / 2, particleOptions));
                    }
                }
            }
            
            const constraints = [];
            for (let i = 0; i < particles.length; i++) {
                const particleA = particles[i];
                for (let j = i + 1; j < particles.length; j++) {
                    const particleB = particles[j];
                    const distance = Vector.magnitude(Vector.sub(particleA.position, particleB.position));
                    if (distance < particleRadius * 2.5) {
                        constraints.push(
                            Constraint.create({
                                bodyA: particleA,
                                bodyB: particleB,
                                stiffness: 0.04,
                                damping: 0.1,
                                render: { visible: false }
                            })
                        );
                    }
                }
            }
            
            // Add constraints to maintain circular shape
            const centerParticle = particles[Math.floor(particles.length / 2)];
            particles.forEach(particle => {
                if (particle !== centerParticle) {
                    constraints.push(
                        Constraint.create({
                            bodyA: centerParticle,
                            bodyB: particle,
                            stiffness: 0.001,
                            damping: 0.1,
                            render: { visible: false }
                        })
                    );
                }
            });
            
            const liquidBody = Composite.create({ bodies: particles, constraints: constraints });
            liquidBody.svgElement = svgElement;
            liquidBody.originalRadius = radius;
            return liquidBody;
        }

        // Load SVG file
        async function loadSVG(url) {
            const response = await fetch(url);
            const svgText = await response.text();
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgElement = svgDoc.documentElement;
            return svgElement;
        }

        // Create blobs with SVG mapping
        async function createBlobs() {
            const svgElement = await loadSVG('walk0001.svg');
            const blobs = [];
            const blobCount = 1;  // Reduced to 1 for simplicity

            for (let i = 0; i < blobCount; i++) {
                const radius = 100;  // Fixed size for simplicity
                const x = canvas.width / 2;
                const y = canvas.height / 2;
                
                const blob = createLiquidBody(x, y, radius, 15, svgElement);
                Composite.add(world, blob);
                blobs.push(blob);
            }

            return blobs;
        }

        // Add mouse control
        const mouse = Mouse.create(render.canvas),
              mouseConstraint = MouseConstraint.create(engine, {
                  mouse: mouse,
                  constraint: {
                      stiffness: 0.2,
                      render: { visible: false }
                  }
              });

        Composite.add(world, mouseConstraint);

        render.mouse = mouse;

        // Initialize the simulation
        let blobs = [];
        async function init() {
            blobs = await createBlobs();
            
            // Fit the render viewport to the scene
            Render.lookAt(render, {
                min: { x: 0, y: 0 },
                max: { x: canvas.width, y: canvas.height }
            });

            // Start the custom rendering
            Events.on(render, 'afterRender', renderBlobs);
        }

        // Custom rendering function
        function renderBlobs() {
            const ctx = render.context;
            ctx.globalCompositeOperation = 'source-over';
            
            blobs.forEach(blob => {
                const particles = blob.bodies;
                const svgElement = blob.svgElement;
                
                // Create a path from the particles
                ctx.beginPath();
                particles.forEach((particle, index) => {
                    if (index === 0) {
                        ctx.moveTo(particle.position.x, particle.position.y);
                    } else {
                        ctx.lineTo(particle.position.x, particle.position.y);
                    }
                });
                ctx.closePath();
                
                // Use the path as a clipping mask
                ctx.save();
                ctx.clip();
                
                // Draw the SVG
                const svgString = new XMLSerializer().serializeToString(svgElement);
                const img = new Image();
                img.onload = () => {
                    const scale = (blob.originalRadius * 2) / Math.max(svgElement.width.baseVal.value, svgElement.height.baseVal.value);
                    const centerX = particles.reduce((sum, p) => sum + p.position.x, 0) / particles.length;
                    const centerY = particles.reduce((sum, p) => sum + p.position.y, 0) / particles.length;
                    
                    ctx.drawImage(img, 
                        centerX - (svgElement.width.baseVal.value * scale) / 2, 
                        centerY - (svgElement.height.baseVal.value * scale) / 2, 
                        svgElement.width.baseVal.value * scale, 
                        svgElement.height.baseVal.value * scale
                    );
                    
                    ctx.restore();
                };
                img.src = 'data:image/svg+xml;base64,' + btoa(svgString);
            });
        }

        init();

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render.canvas.width = canvas.width;
            render.canvas.height = canvas.height;
            render.bounds.max.x = canvas.width;
            render.bounds.max.y = canvas.height;
            Render.lookAt(render, {
                min: { x: 0, y: 0 },
                max: { x: canvas.width, y: canvas.height }
            });

            // Update wall positions
            Body.setPosition(walls[0], { x: canvas.width / 2, y: -wallThickness / 2 });
            Body.setPosition(walls[1], { x: canvas.width / 2, y: canvas.height + wallThickness / 2 });
            Body.setPosition(walls[2], { x: -wallThickness / 2, y: canvas.height / 2 });
            Body.setPosition(walls[3], { x: canvas.width + wallThickness / 2, y: canvas.height / 2 });
            
            Body.setVertices(walls[0], Matter.Vertices.fromPath(`0 0 ${canvas.width} 0 ${canvas.width} ${wallThickness} 0 ${wallThickness}`));
            Body.setVertices(walls[1], Matter.Vertices.fromPath(`0 0 ${canvas.width} 0 ${canvas.width} ${wallThickness} 0 ${wallThickness}`));
            Body.setVertices(walls[2], Matter.Vertices.fromPath(`0 0 ${wallThickness} 0 ${wallThickness} ${canvas.height} 0 ${canvas.height}`));
            Body.setVertices(walls[3], Matter.Vertices.fromPath(`0 0 ${wallThickness} 0 ${wallThickness} ${canvas.height} 0 ${canvas.height}`));
        });
    </script>
</body>
</html>
