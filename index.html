import React, { useState, useEffect, useRef } from 'react';

const SquishyEntities = () => {
  const [entities, setEntities] = useState([]);
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [pattern, setPattern] = useState(null);
  const requestRef = useRef();
  const canvasRef = useRef();

  const ENTITY_COUNT = 10;
  const ENTITY_RADIUS = 50;
  const DAMPENING = 0.98;
  const SPRING_STRENGTH = 0.03;
  const GRAVITY = 0.2;
  const COLLISION_DAMPENING = 0.8;

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    const loadSVG = async () => {
      try {
        const response = await fetch('/walk0001.svg');
        const svgText = await response.text();
        const img = new Image();
        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText);
        img.onload = () => {
          const pat = ctx.createPattern(img, 'no-repeat');
          setPattern(pat);
        };
      } catch (error) {
        console.error('Error loading SVG:', error);
      }
    };

    loadSVG();

    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initEntities();
    };

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const handleMouseMove = (e) => {
      const rect = canvas.getBoundingClientRect();
      setMousePos({ x: e.clientX - rect.left, y: e.clientY - rect.top });
    };

    canvas.addEventListener('mousemove', handleMouseMove);

    return () => {
      window.removeEventListener('resize', resizeCanvas);
      canvas.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);

  const initEntities = () => {
    const canvas = canvasRef.current;
    const newEntities = Array.from({ length: ENTITY_COUNT }, () => ({
      x: Math.random() * (canvas.width - ENTITY_RADIUS * 2) + ENTITY_RADIUS,
      y: Math.random() * (canvas.height - ENTITY_RADIUS * 2) + ENTITY_RADIUS,
      vx: 0,
      vy: 0,
      radius: ENTITY_RADIUS,
      rotation: 0,
    }));
    setEntities(newEntities);
  };

  const checkCollision = (e1, e2) => {
    const dx = e2.x - e1.x;
    const dy = e2.y - e1.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance < e1.radius + e2.radius) {
      const angle = Math.atan2(dy, dx);
      const sin = Math.sin(angle);
      const cos = Math.cos(angle);

      // Rotate velocities
      const vx1 = e1.vx * cos + e1.vy * sin;
      const vy1 = e1.vy * cos - e1.vx * sin;
      const vx2 = e2.vx * cos + e2.vy * sin;
      const vy2 = e2.vy * cos - e2.vx * sin;

      // Collision reaction
      const vxTotal = vx1 - vx2;
      vx1 = ((e1.radius - e2.radius) * vx1 + 2 * e2.radius * vx2) / (e1.radius + e2.radius);
      vx2 = vxTotal + vx1;

      // Update positions to prevent sticking
      const absV = Math.abs(vx1) + Math.abs(vx2);
      const overlap = (e1.radius + e2.radius) - distance;
      e1.x -= overlap * (vx1 / absV);
      e2.x += overlap * (vx2 / absV);

      // Rotate positions back
      e1.vx = vx1 * cos - vy1 * sin;
      e1.vy = vy1 * cos + vx1 * sin;
      e2.vx = vx2 * cos - vy2 * sin;
      e2.vy = vy2 * cos + vx2 * sin;

      e1.vx *= COLLISION_DAMPENING;
      e1.vy *= COLLISION_DAMPENING;
      e2.vx *= COLLISION_DAMPENING;
      e2.vy *= COLLISION_DAMPENING;
    }
  };

  const animate = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const updatedEntities = entities.map((entity) => {
      let dx = mousePos.x - entity.x;
      let dy = mousePos.y - entity.y;
      let distance = Math.sqrt(dx * dx + dy * dy);

      if (distance < ENTITY_RADIUS * 2) {
        const angle = Math.atan2(dy, dx);
        const targetX = mousePos.x - Math.cos(angle) * ENTITY_RADIUS * 2;
        const targetY = mousePos.y - Math.sin(angle) * ENTITY_RADIUS * 2;
        entity.vx += (targetX - entity.x) * SPRING_STRENGTH;
        entity.vy += (targetY - entity.y) * SPRING_STRENGTH;
      }

      entity.vy += GRAVITY;
      entity.vx *= DAMPENING;
      entity.vy *= DAMPENING;

      entity.x += entity.vx;
      entity.y += entity.vy;

      // Update rotation based on horizontal velocity
      entity.rotation = Math.atan2(entity.vy, entity.vx);

      // Boundary checks
      if (entity.x < entity.radius) {
        entity.x = entity.radius;
        entity.vx *= -COLLISION_DAMPENING;
      }
      if (entity.x > canvas.width - entity.radius) {
        entity.x = canvas.width - entity.radius;
        entity.vx *= -COLLISION_DAMPENING;
      }
      if (entity.y < entity.radius) {
        entity.y = entity.radius;
        entity.vy *= -COLLISION_DAMPENING;
      }
      if (entity.y > canvas.height - entity.radius) {
        entity.y = canvas.height - entity.radius;
        entity.vy *= -COLLISION_DAMPENING;
      }

      return entity;
    });

    // Check collisions between entities
    for (let i = 0; i < updatedEntities.length; i++) {
      for (let j = i + 1; j < updatedEntities.length; j++) {
        checkCollision(updatedEntities[i], updatedEntities[j]);
      }
    }

    setEntities(updatedEntities);

    // Draw entities
    if (pattern) {
      entities.forEach((entity) => {
        ctx.save();
        ctx.translate(entity.x, entity.y);
        ctx.rotate(entity.rotation);
        ctx.beginPath();
        ctx.arc(0, 0, entity.radius, 0, Math.PI * 2);
        ctx.fillStyle = pattern;
        ctx.fill();
        ctx.restore();
      });
    }

    requestRef.current = requestAnimationFrame(animate);
  };

  useEffect(() => {
    requestRef.current = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(requestRef.current);
  }, [entities, mousePos, pattern]);

  return (
    <canvas ref={canvasRef} style={{ display: 'block', width: '100vw', height: '100vh' }} />
  );
};

export default SquishyEntities;
