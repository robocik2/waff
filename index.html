<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deformable Soft Body Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Constraint = Matter.Constraint,
              Mouse = Matter.Mouse,
              Events = Matter.Events;

        const engine = Engine.create();
        const world = engine.world;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvas.width,
                height: canvas.height,
                wireframes: false,
                background: '#f4f4f4'
            }
        });

        // Create walls
        const wallThickness = 50;
        const walls = [
            Bodies.rectangle(canvas.width / 2, -wallThickness / 2, canvas.width, wallThickness, { isStatic: true }),
            Bodies.rectangle(canvas.width / 2, canvas.height + wallThickness / 2, canvas.width, wallThickness, { isStatic: true }),
            Bodies.rectangle(-wallThickness / 2, canvas.height / 2, wallThickness, canvas.height, { isStatic: true }),
            Bodies.rectangle(canvas.width + wallThickness / 2, canvas.height / 2, wallThickness, canvas.height, { isStatic: true })
        ];
        Composite.add(world, walls);

        // Create soft bodies
        function createSoftBody(x, y, columns, rows, columnGap, rowGap, radius, options) {
            const group = Body.nextGroup(true);
            const particleOptions = {
                friction: 0.05,
                collisionFilter: { group: group },
                render: {
                    visible: false
                }
            };
            const constraintOptions = {
                stiffness: 0.2,
                render: {
                    visible: false
                }
            };

            let softBody = Composites.softBody(x, y, columns, rows, columnGap, rowGap, false, radius, particleOptions, constraintOptions);
            
            const parts = softBody.bodies;
            for (let i = 0; i < parts.length; i++) {
                parts[i].render.fillStyle = options.color;
            }

            return softBody;
        }

        const softBodies = [];
        const numBodies = 5;
        const minSize = Math.min(canvas.width, canvas.height) * 0.15;
        const maxSize = Math.min(canvas.width, canvas.height) * 0.25;

        for (let i = 0; i < numBodies; i++) {
            const x = wallThickness + Math.random() * (canvas.width - 2 * wallThickness);
            const y = wallThickness + Math.random() * (canvas.height - 2 * wallThickness);
            const size = minSize + Math.random() * (maxSize - minSize);
            const color = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.7)`;
            const softBody = createSoftBody(x, y, 5, 5, 20, 20, 8, { color: color });
            softBodies.push(softBody);
            Composite.add(world, softBody);
        }

        // Create cursor body
        const cursorRadius = 20;
        const cursor = Bodies.circle(0, 0, cursorRadius, {
            isStatic: true,
            render: {
                fillStyle: 'rgba(255, 0, 0, 0.5)'
            }
        });
        Composite.add(world, cursor);

        // Mouse control
        const mouse = Mouse.create(render.canvas);
        Events.on(engine, 'afterUpdate', function() {
            if (!mouse.position.x) return;
            cursor.position.x = mouse.position.x;
            cursor.position.y = mouse.position.y;
        });

        // Run the engine
        Runner.run(engine);

        // Run the renderer
        Render.run(render);

        // Resize handling
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render.bounds.max.x = canvas.width;
            render.bounds.max.y = canvas.height;
            render.options.width = canvas.width;
            render.options.height = canvas.height;
            Render.setPixelRatio(render, window.devicePixelRatio);

            // Update wall positions
            Composite.remove(world, walls);
            walls[0].position.y = -wallThickness / 2;
            walls[0].vertices[1].x = walls[0].vertices[2].x = canvas.width;
            walls[1].position.y = canvas.height + wallThickness / 2;
            walls[1].vertices[1].x = walls[1].vertices[2].x = canvas.width;
            walls[2].position.x = -wallThickness / 2;
            walls[2].vertices[2].y = walls[2].vertices[3].y = canvas.height;
            walls[3].position.x = canvas.width + wallThickness / 2;
            walls[3].vertices[2].y = walls[3].vertices[3].y = canvas.height;
            Composite.add(world, walls);
        });
    </script>
</body>
</html>
